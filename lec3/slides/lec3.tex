\input{../../common/header}

\subtitle{Лекция 3}

\begin{document}

  \frame{\titlepage}


  \section*{Содержание} {
    \frame{\tableofcontents[hideallsubsections]}


  \section{Процедурное программирование}
    \begin{tikzpicture}
      \paradigmsProc
    \end{tikzpicture}

  \frame {
    \frametitle{Процедурное программирование (Procedural Programming)}
    \begin{itemize}
        \item программу разделяют на \underline{подпрограммы} (процедуры и функции)
        \begin{itemize}
          \item \textbf{функции} \underline{возвращают} значения (например $y=\sin({x})$)
          \item \textbf{процедуры} \underline{не возвращают} значений (например print~"hello")
        \end{itemize}
      \item подпрограмма может принимать некие \underline{аргументы} (или параметры)
    \end{itemize}
  }

  \frame {
    \frametitle{Переменные}

    \begin{itemize}
      \item \textbf{локальные} доступны только \underline{внутри подпрограммы}
      \item \textbf{глобальные} доступны \underline{из всех подпрограмм}
    \end{itemize}
  }

  \frame {
    \frametitle{Переменные}
    \framesubtitle{Время жизни переменных}

    \begin{itemize}
      \item \textbf{локальные} (в большинстве языков) уничтожаются \underline{перед выходом из функции}
      \item \textbf{глобальные} \underline{никогда} не уничтожаются
    \end{itemize}
  }

  \frame {
    \frametitle{Изменяемое состояние (Mutable State) и побочные эффекты (Side Effects)}

    \vspace{0.5cm}
    \underline{Глобальные переменные} хранят некое \underline{состояние} программы

    \vspace{0.5cm}
    На это \underline{состояние} влияют \underline{побочные эффекты}
  }

\begin{frame}[fragile]
  \frametitle{Процедура}
  \begin{minted}{python}
# глобальная переменная
students = ['Вася', 'Петя']

# объявление процедуры
def printAllStudents():
    print 'all students:'
    for i in students:
        print i

# вызов процедуры
printAllStudents()
  \end{minted}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Процедура с побочным эффектом}
  \begin{minted}{python}
# глобальная переменная
students = ['Вася', 'Петя']
...
# процедура с побочным эффектом
def addStudent(name):
    global students  # разрешает запись
                     # в глоб. переменную
    students = students + [name]

# вызов процедуры
addStudent('Семён')
  \end{minted}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Процедура может вызывать другие процедуры}
  \begin{minted}{python}
def addStudent(name):
    global students
    students = students + [name]
    printAllStudents()

addStudent('Семён')
  \end{minted}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Функция}
  Значение функции можно присвоить переменной
  \begin{minted}{python}
students = ['Вася', 'Петя']

def getNumberOfStudents():
    n = len(students)          # локальная переменная
    return n

def isStudentInList(name):
    for i in students:
        if i == name:
            return True
    return False

num = getNumberOfStudents()
print num                       # 2
print isStudentInList('Вася')   # True
  \end{minted}
\end{frame}

  \frame {
    В некоторых языках (Python, например) процедуры тоже возвращают (не очень полезное) значение

    \vspace{0.5cm}
    Многие забили на термин <<процедура>> и стали всё называть функциями
  }

  \frame {
    \frametitle{Многоуровневые системы}
      \layersInRealLife
      \vspace{0.5cm}
      \textbf{Высокий} уровень просит либо \underline{свой} либо \underline{более низкий} уровень
      (а не наоборот)
    }

    \frame {
      \layersInRealLife
      \vspace{0.5cm}

      \textbf{Правильно}:

      Д просит П создать продукт

      П просит Х и М выполнить подзадачи для него

      М и Х возвращают результаты своих работ П

      П соединил результаты в продукт и вернул Д
    }

    \frame {
      \layersInRealLife
      \vspace{0.5cm}

      \textbf{Неправильно}:
      Д просит Х написать программу
    }

    \frame {
      \layersInRealLife
      \vspace{0.5cm}

      \textbf{Неправильно}:

      М вызвался сам сделать продукт. Сделал и впарил результат Д
    }

    \frame {
      \layersInRealLife
      \vspace{0.5cm}

      \textbf{Неправильно}:

      П просит Д дать ему задачу <<разработать велосипед>>
    }

    \frame {
      \layersInRealLife
      \vspace{0.5cm}

      \textbf{Плохо / спорно}:

      Д просит М выполнить задачу

      (Лучше обратиться к П, чтобы тот передал задачу М)
    }

    \frame {
      \frametitle{В процедурных программах тоже самое}

      Пример типичной архитектуры процедурной программы:
      \vspace{0.5cm}
      \begin{itemize}
        \item Главная логика
          \begin{itemize}
            \item Ввод данных
              \begin{itemize}
                \item Валидация ввода
              \end{itemize}
            \item Обработка данных
              \begin{itemize}
                \item Helpers для обработки данных
              \end{itemize}
            \item Вывод данных
          \end{itemize}
      \end{itemize}
    }

    \frame {
      \frametitle{Пример процедурной программы (Python)}

      Вывести всех студентов, заваливших экзамен

      Ввод: двумерный массив из студентов и их оценок
      Вывод: имена студентов, оценка которых <= 2

      В случае неверного ввода оценки выводить ошибку "input error" и выходить из программы
    }

    \frame {
      \frametitle{В процедурных программах тоже самое}

      Пример типичной архитектуры процедурной программы:
      \vspace{0.5cm}
      \begin{itemize}
        \item Главная логика (main)
          \begin{itemize}
            \item Ввод данных (inputAllStudents)
              \begin{itemize}
                \item Валидация ввода (isNumber)
              \end{itemize}
            \item Обработка данных (findFailedStudents)
              \begin{itemize}
                \item Helpers для обработки данных (isFailedGrade)
              \end{itemize}
            \item Вывод данных (outputFailedStudents)
          \end{itemize}
      \end{itemize}
    }

\frame {
    Программирование \textbf{сверху вниз} --- сначала реализовать \underline{все высокоуровневые} функции,
    потом \underline{более низкого} уровня, потом еще более низкого уровня...

  \vspace{0.5cm}
  Программирование \textbf{снизу вверх} --- наоборот, от \underline{низкоуровневых} к \underline{высокоуровневым}

  \vspace{0.5cm}
  На практике в чистом виде ни то ни другое не применяют
}

\begin{frame}[fragile]
  \begin{minted}{python}
allStudents = []
failedStudentsIndexes = []

# high-level functions (1)
def inputAllStudents(): pass        # 1
def outputFailedStudents(): pass    # 5
def findFailedStudents(): pass      # 3

# low-level functions (2)
def isNumber(s): pass               # 2
def isFailedGrade(grade): pass      # 4

if inputAllStudents():              # 0
    findFailedStudents()
    outputFailedStudents()
else:
    print "input error"
  \end{minted}
\end{frame}

\begin{frame}[fragile]
  \begin{minted}{python}
allStudents = []
...
def inputAllStudents():
    global allStudents
    nStr = raw_input("input students number: ")
    if not isNumber(nStr):
        return False
    else:
        ...
  \end{minted}
\end{frame}

\begin{frame}[fragile]
  \begin{minted}{python}
    else:
        n = int(nStr)
        for i in range(n):
            name = raw_input("input name: ")
            gradeStr = raw_input("input grade: ")
            if not isNumber(gradeStr):
                return False
            else:
                grade = int(gradeStr)
                pair = [name, grade]
                allStudents = allStudents + [pair]
        return True
  \end{minted}
\end{frame}

\begin{frame}[fragile]
  \begin{minted}{python}
def isNumber(s):
    if len(s) > 0:
        for character in s:
            if character < '0' or character > '9':
                return False
        return True
    else:
        return False
  \end{minted}
\end{frame}

\begin{frame}[fragile]
  \begin{minted}{python}
allStudents = [['Вася', 2], ['Петя', 5]]
failedStudentsIndexes = []
...
def findFailedStudents():
    global failedStudentsIndexes
    n = len(allStudents)
    for i in range(n):
        name = allStudents[i][0]
        grade = allStudents[i][1]
        if isFailedGrade(grade):
            failedStudentsIndexes = failedStudentsIndexes + [i]
  \end{minted}
\end{frame}

\begin{frame}[fragile]
  \begin{minted}{python}
def isFailedGrade(grade):
    if grade <= 2:
        return True
    else:
        return False
  \end{minted}
\end{frame}

\begin{frame}[fragile]
  Рефакторинг: избавились от \underline{magic number} обзначив его за константу
  \vspace{1cm}
  \begin{minted}{python}
BAD_GRADE = 2
...
def isFailedGrade(grade):
    if grade <= BAD_GRADE:
        return True
    else:
        return False
  \end{minted}
\end{frame}

\begin{frame}[fragile]
  Рефакторинг: избавились от лишнего условия (оператор <= и так возвращает нужное нам логическое значение)
  \vspace{1cm}
  \begin{minted}{python}
BAD_GRADE = 2
...
def isFailedGrade(grade):
    return grade <= BAD_GRADE
  \end{minted}
\end{frame}

\begin{frame}[fragile]
  \begin{minted}{python}
allStudents = [['Вася', 2], ['Петя', 5]]
failedStudentsIndexes = [0]
...
def outputFailedStudents():
    for i in failedStudentsIndexes:
        name = allStudents[i][0]
        print name
  \end{minted}
\end{frame}

\begin{frame}[fragile]
  Спорный момент: вообще-то этому коду не место в самом высоком уровне:

  \vspace{1cm}
  \begin{minted}{python}
    print "input error"
  \end{minted}
\end{frame}

\begin{frame}[fragile]
  Правильней будет выделить и его в отдельную high-level функцию:

  \vspace{0.5cm}
  \begin{minted}{python}
def printError():
    print "input error"

...

if ...
else:
    printError()
  \end{minted}

  \vspace{0.5cm}
  или вовсе вставить внутрь существующей high-level функции (inputAllStudents)
\end{frame}

\section{Рекурсивные функции}
\begin{frame}[fragile]
  \frametitle{Рекурсивные функции}

  Подпрограммы могут вызывать сами себя
  % TODO: пример функции, которая один раз вызывает себя
\end{frame}

\frame {
  \frametitle{Зачем?}
  Суть в том, чтобы повторить какой-то участок кода

  Обычно этого добиваются циклами, но это не всегда выглядит лаконично и очевидно
  \begin{center}
    \includegraphics[scale=0.16]{pictures/recursive_vs_iteractive.png}
  \end{center}
}

\frame {
  \frametitle{Пример}

  Написать функцию f(n), которая вернёт сумму арифметической прогрессии
  $1 + 2 + 3 + ... + (n - 1) + n$
}

\begin{frame}[fragile]
  \frametitle{Итерационный алгоритм}
  \begin{minted}{java}
static int f(int n) {
    int sum = 0;
    for (int i = 1; i <= n; i = i + 1) {
        sum = sum + i;
    }
    return sum;
}
  \end{minted}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Итерационный алгоритм 2}
  \begin{minted}{java}
static int f(int n) {
    int sum = 0;
    for (int i = n; i >= 1; i = i - 1) {
        sum = sum + i;
    }
    return sum;
}
  \end{minted}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Итерационный алгоритм 3}
  \begin{minted}{java}
static int f(int n) { // аргументы функции - тоже
                      // локальные переменные
    int sum = 0;
    while (n >= 1) {
        sum = sum + n;
        n = n - 1;    // их тоже можно менять
    }
    return sum;
}
  \end{minted}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Рекурсивный алгоритм}
  \begin{minted}{java}
static int f(int n) {
    if (n <= 1) {
        return 1;
    } else {
        return n + f(n - 1); // последним будет
                             // вызов оператора +
    }
}
  \end{minted}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Хвостовая рекурсия}
  \begin{minted}{java}
static int f(int n, int sum = 0) { // значение аргумента
                                   // по-умолчанию
    if (n <= 0) {
        return sum;
    } else {
        return f(n - 1, sum + n); // последним будет
                                  // выполнен вызов
                                  // функции f
    }
}
  \end{minted}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Функциональщики пишут еще более хацкерно}
  \begin{minted}{python}
def f(n, sum = 0):
    return sum if n <= 0 else f(n - 1, sum + n)
  \end{minted}
\end{frame}

\end{document}
